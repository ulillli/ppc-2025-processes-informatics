# Подсчет числа буквенных символов в строке

- Student: Папулина Юлия Андреевна, group 3823Б1ФИ3
- Technology: SEQ | MPI 
- Variant: 22

## 1. Введение
Задача подсчета буквенных символов в строке является одной из базовых операций в обработке текстовых данных и представляет собой идеальный пример для освоения принципов параллельного программирования. Сейчас, когда объемы обрабатываемой текстовой информации постоянно растут, эффективная реализация таких операций становится особенно важной. В рамках данной работы реализован MPI-алгоритм, демонстрирующий ключевые аспекты параллельного программирования: декомпозицию задачи, балансировку нагрузки и коллективные операции.

## 2. Постановка задачи
**Формальная постановка:** для заданной строки S длиной N подсчитать количество символов, являющихся буквами латинского алфавита.

**Входные данные:** строка S произвольной длины

**Выходные данные:** целое число - количество буквенных символов

**Ограничения:**
- Решение должно быть масштабируемым для различного числа процессов

## 3. Последовательная версия(Baseline)
Алгоритм последовательно проверяет каждый символ строки, определяя принадлежность к латинскому алфавиту с помощью функции int isalpha( int ch )
```cpp
int result = 0;
  if (n <= 0) {
    return 0;
  }
  for (int i = 0; i < n; i++) {
    unsigned char c = s[i];
    if (isalpha(c) != 0) {
      result++;
    }
  }
  return result;
```

## 4. Параллельная версия

### 4.1. Разделение данных
 Используется блочное распределение данных с равномерным распределением остатка:
 - базовый размер блока: len = length / num_processes
 - остаток: remainder = length % num_processes
 - процесс i получает: len + (i < remainder ? 1 : 0) символов (таким образом, все ramainder процессов получат + дополнительный символ к обработке)
 
### 4.2. Взаимодействие процессов
#### Процесс 0 (Координатор)
 - читает входную строку
 - рассылает базовый размер блока(len) и остаток(reminder) остальным потокам(MPI_Bcast)
 - инициализирует свою часть обработки строки
 - отправка данных(часть строки) для обработки другим процессам через for (MPI_Send)
 - cобирает результаты (MPI_Reduce)

#### Процессы 1..N-1 (Рабочие процессы)
- получают параметры: размер блока, остаток(MPI_Bcast)
- получают свою часть строки для обработки(MPI_Recv)
- выполняют подсчет на своей части
- отправляют результат (MPI_Reduce)

### 4.3. Псевдокод алгоритма
```pseudocode
FUNCTION:
    │
    ├─ INITIALIZATION
    │   • Get process rank
    │   • Initialize variables
    │
    ├─ DATA DISTRIBUTION PHASE
    │   │
    │   ├─ IF rank = 0 (MASTER):
    │   │   • Read input string
    │   │   • Calculate base_len = length / procNum
    │   │   • Calculate remainder = length % procNum
    │   │   • Broadcast base_len, remainder
    │   │   • Counting the processed part for master
    │   │   • For each worker i:
    │   │     - Calculate chunk boundaries
    │   │     - Send chunk_size
    │   │     - Send chunk_data 
    │   │
    │   └─ ELSE (WORKER):
    │       • Receive broadcast base_len, remainder
    │       • Receive chunk_size
    │       • Receive chunk_data 
    │
    ├─ COMPUTATION PHASE
    │   • Each process: Count letters in local_data
    │
    ├─ RESULT COLLECTION PHASE
    │   • MPI_Reduce: SUM all local_count → process 0
    │   • Broadcast result
    │   • Set result
    │
    └─ RETURN success
```
## 5. Детали реализации

### 5.1. Файловая структура проекта
papulina_y_count_of_letters/  
├── common/include/common.hpp  
├── seq/include/ops_seq.hpp  
├── seq/src/ops_seq.cpp  
├── mpi/include/ops_mpi.hpp  
├── mpi/src/ops_mpi.cpp  
├── tests/functional/main.cpp  
├── tests/performance/main.cpp  
└── data/  

### 5.2. Ключевые классы и функции

- `InType = std::string` - тип входных данных (строка)
- `OutType = int` - тип выходных данных (количество букв)
- `CountOfLetters(const char* s, const int& n)` - функция подсчета символов
- `RunImpl()` - основная логика последовательного выполнения
- `ValidationImpl()` - проверка валидности входных данных
- `PreProcessingImpl()` - подготовительные операции
- `PostProcessingImpl()` - завершающие операции
- `class PapulinaYRunFuncTestsProcesses` - параметрические функциональные тесты
- `class PapulinaYRunPerfTestsProcesses` - параметрические тесты производительности

### 5.3. Использование памяти

**SEQ версия:**
- хранит всю входную строку в памяти
- O(N) память, где N - длина строки
- минимальные накладные расходы(отсутствуют затраты на синхронизацию между потоками/процессами)

**MPI версия:**
- процесс 0: хранит всю строку + буферы для коммуникации
- рабочие процессы: хранят только свою часть строки
- дополнительная память для MPI буферов сообщений
- эффективное распределение памяти при больших N

## 6. Экспериментальное окружение

**Hardware/OS:**
- **CPU:** Intel Core i5-11400H (6 cores, 12 threads, 2.70 GHz base frequency)
- **RAM:** 16.0 GB DDR4
- **Storage:** SSD 512 GB
- **OS:** Windows 10 

**Toolchain:**
- **Compiler:** Microsoft Visual C++ 2019 (MSVC 19.29.30153)
- **MPI Implementation:** Microsoft MPI Version10.1.12498.52
- **Build System:** CMake 3.30.3
- **Build Type:** Release

**Environment:**
- **PPC_NUM_PROC:** 1, 2, 4, 6 

**Data:**  строка из 40 000 000 латинских символов

## 7. Результаты

### 7.1 Корректность
Корректность реализации была проверена через комплексную систему тестирования, включающую:
- 20 функциональных тестов(пустая строка, строка из одного символа, строка с генерированными символами)
- тест на производительность на стабильных данных 

**Структура параметров теста:**
- строка (generate - если тест на генерацию)
- ожидаемый результат
- название теста(его номер)

### 7.2 Производительность
Время выполнения для строки длиной 40 000 000 символов:

| Mode        | Count | Time, s | Speedup | Efficiency |
|-------------|-------|---------|---------|------------|
| seq         | 1     | 0.0951  | 1.00    | N/A        |
| mpi         | 2     | 0.0937  | 1.01    | 50.5%      |
| mpi         | 3     | 0.0718  | 1.32    | 44.0%      |
| mpi         | 4     | 0.0737  | 1.29    | 32.3%      |
| mpi         | 6     | 0.0778  | 1.22    | 20.3%      |

**Анализ результатов:**
- минимальное ускорение: наблюдается незначительное ускорение (1.01-1.32x) даже при использовании нескольких процессов
- низкая эффективность: эффективность варьируется от 20.3% до 50.5%, что указывает на значительные накладные расходы
- оптимальная конфигурация: максимальное ускорение достигается при 3 процессах (1.32x)

**Анализ узких мест:**
- коммуникационные затраты: время передачи данных между процессами превышает время вычислений для данного объема данных
- неидеальное распределение: алгоритм распределения данных создает дополнительную нагрузку

## 8. Заключение
В результате работы в учебных целях разработаны последовательная (SEQ) и параллельная (MPI) версии программы, подсчитывающей число латинских символов в строке. Несмотря на ограниченную практическую эффективность для конкретной задачи подсчета символов, реализация успешно демонстрирует принципы распределенных вычислений и может служить основой для более сложных алгоритмов обработки текста.

## 9. Источники
1. Microsoft MPI : документация [Электронный ресурс] // Microsoft Learn. – URL: https://learn.microsoft.com/ru-ru/message-passing-interface/microsoft-mpi (дата обращения: 03.11.2025).
2. Сысоев А. В. Курс лекций по параллельному программированию
